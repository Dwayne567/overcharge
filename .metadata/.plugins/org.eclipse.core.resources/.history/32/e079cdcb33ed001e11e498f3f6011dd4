package com.spark.overcharge.services;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spark.overcharge.dto.CardDto;
import com.spark.overcharge.dto.DeckDto;
import com.spark.overcharge.entity.Card;
import com.spark.overcharge.entity.Deck;
import com.spark.overcharge.entity.User;
import com.spark.overcharge.repository.CardRepository;
import com.spark.overcharge.repository.DeckRepository;
import com.spark.overcharge.repository.UserRepository;

import jakarta.transaction.Transactional;

@Service
public class DeckServiceImpl implements DeckService {

	@Autowired
	private UserRepository userRepository;

	@Autowired
	private DeckRepository deckRepository;

	@Autowired
	private CardRepository cardRepository;
	
	@Transactional
	public Deck createDeck(DeckDto deckDto) {
		Deck deck = new Deck();

		User user = userRepository.findById(deckDto.getUserId())
				.orElseThrow(() -> new IllegalArgumentException("User with id " + deckDto.getUserId() + " not found"));

		deck.setUser(user);
		deck.setTitle(deckDto.getTitle());
		deck.setCards(deckDto.getCards());

		Deck savedDeck = deckRepository.save(deck);

		if (deckDto.getCards() != null) {
			for (CardDto card : deckDto.getCards()) {
				Card newCard = new Card();
				newCard.setDeckId(savedDeck.getId());
				newCard.setQuestion(card.getQuestion());
				newCard.setAnswer(card.getAnswer());
				cardRepository.save(newCard);
			}
		}

		return savedDeck;
	}

	public List<DeckDto> getAllDecks() {
		List<Deck> decks = deckRepository.findAll();
		return decks.stream().map(Deck::getDto).collect(Collectors.toList());
	}

	public List<DeckDto> getAllDecksByUserId(Long userId) {
		List<Deck> decks = deckRepository.findByUserId(userId);
		return decks.stream().map(Deck::getDto).collect(Collectors.toList());
	}

	public DeckDto getDeckByDeckId(Long deckId) {
		Optional<Deck> optionalDeck = deckRepository.findById(deckId);
		if (optionalDeck.isPresent()) {
			Deck deck = optionalDeck.get();
			DeckDto deckDto = deck.getDto();
			List<Card> cards = cardRepository.findByDeckId(deckId).orElse(null);
			if (cards != null) {
				List<CardDto> cardDtos = cards.stream().map(Card::getDto).collect(Collectors.toList());
				deckDto.setCards(cardDtos);
			}
			return deckDto;
		} else {
			return null;
		}
	}
	
	@Transactional
	public DeckDto updateDeck(Long deckId, DeckDto deckDto) {
	    // Retrieve the existing deck from the repository
	    Deck existingDeck = deckRepository.findById(deckId)
	            .orElseThrow(() -> new IllegalArgumentException("Deck with id " + deckId + " not found"));

	    // Update the title and cards of the existing deck with the values from the DTO
	    existingDeck.setTitle(deckDto.getTitle());
	    existingDeck.setCards(deckDto.getCards());

	    // Save the updated deck
	    Deck updatedDeck = deckRepository.save(existingDeck);

	    // If the DTO contains cards, update or create them
	    if (deckDto.getCards() != null) {
	        for (CardDto cardDto : deckDto.getCards()) {
	            Card card;
	            // Check if the card already exists in the deck
	            if (cardDto.getId() != null) {
	                // If the card exists, retrieve it from the repository
	                card = cardRepository.findById(cardDto.getId())
	                        .orElseThrow(() -> new IllegalArgumentException("Card with id " + cardDto.getId() + " not found"));
	                // Update the question and answer of the existing card
	                card.setQuestion(cardDto.getQuestion());
	                card.setAnswer(cardDto.getAnswer());
	            } else {
	                // If the card doesn't exist, create a new one
	                card = new Card();
	                card.setDeckId(updatedDeck.getId());
	                card.setQuestion(cardDto.getQuestion());
	                card.setAnswer(cardDto.getAnswer());
	            }
	            // Save the card
	            cardRepository.save(card);
	        }
	    }

	    return updatedDeck.getDto();
	}

	public boolean deleteDeck(Long id) {
		Optional<Deck> optionalDeck = deckRepository.findById(id);
		if (optionalDeck.isPresent()) {
			deckRepository.deleteById(id);
			return true;
		}
		return false;
	}

}
