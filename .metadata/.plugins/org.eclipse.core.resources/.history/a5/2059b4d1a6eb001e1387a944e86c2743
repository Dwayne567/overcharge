package com.spark.overcharge.services;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.spark.overcharge.dto.CardDto;
import com.spark.overcharge.dto.DeckDto;
import com.spark.overcharge.entity.Card;
import com.spark.overcharge.entity.Deck;
import com.spark.overcharge.entity.User;
import com.spark.overcharge.repository.CardRepository;
import com.spark.overcharge.repository.DeckRepository;
import com.spark.overcharge.repository.UserRepository;

@Service
public class DeckServiceImpl implements DeckService {

	@Autowired
	private UserRepository userRepository;

	@Autowired
	private DeckRepository deckRepository;

	@Autowired
	private CardRepository cardRepository;

	public Deck createDeck(DeckDto deckDto) {
		Deck deck = new Deck();

		User user = userRepository.findById(deckDto.getUserId())
				.orElseThrow(() -> new IllegalArgumentException("User with id " + deckDto.getUserId() + " not found"));

		deck.setUser(user);
		deck.setTitle(deckDto.getTitle());
		deck.setCards(deckDto.getCards());

		Deck savedDeck = deckRepository.save(deck);

		if (deckDto.getCards() != null) {
			for (CardDto card : deckDto.getCards()) {
				Card newCard = new Card();
				newCard.setDeckId(savedDeck.getId());
				newCard.setQuestion(card.getQuestion());
				newCard.setAnswer(card.getAnswer());
				cardRepository.save(newCard);
			}
		}

		return savedDeck;
	}

	public DeckDto updateDeck(Long deckId, DeckDto deckDto) {
		deckRepository.deleteById(deckId);
		Deck deck = new Deck();

		User user = userRepository.findById(deckDto.getUserId())
				.orElseThrow(() -> new IllegalArgumentException("User with id " + deckDto.getUserId() + " not found"));

		deck.setUser(user);
		deck.setTitle(deckDto.getTitle());
		deck.setCards(deckDto.getCards());
		System.out.println("Deck: " + deck);
		Deck savedDeck = deckRepository.save(deck);
		System.out.println("savedDeck: " + savedDeck);

		if (deckDto.getCards() != null) {
			for (CardDto card : deckDto.getCards()) {
				Card newCard = new Card();
				newCard.setQuestion(card.getQuestion());
				newCard.setAnswer(card.getAnswer());
				newCard.setDeckId(savedDeck.getId());
				cardRepository.save(newCard);
			}
		}

		return savedDeck.getDto();
	}

	public List<DeckDto> getAllDecks() {
		List<Deck> decks = deckRepository.findAll();
		return decks.stream().map(Deck::getDto).collect(Collectors.toList());
	}

	public List<DeckDto> getAllDecksByUserId(Long userId) {
		List<Deck> decks = deckRepository.findByUserId(userId);
		System.out.println("decks --> " + decks);
		return decks.stream().map(Deck::getDto).collect(Collectors.toList());
	}

	public DeckDto getDeckById(Long deckId) {
		Optional<Deck> optionalDeck = deckRepository.findById(deckId);
		if (optionalDeck.isPresent()) {
			Deck deck = optionalDeck.get();
			List<Card> cards = cardRepository.findByDeckId(deckId).orElse(null);
			DeckDto deckDto = deck.getDto();
			if (cards != null) {
				List<CardDto> cardDtos = cards.stream().map(Card::getDto).collect(Collectors.toList());
				deckDto.setCards(cardDtos);
			}
			return deckDto;
		} else {
			return null;
		}
	}

	public boolean deleteDeck(Long id) {
		Optional<Deck> optionalDeck = deckRepository.findById(id);
		if (optionalDeck.isPresent()) {
			deckRepository.deleteById(id);
			return true;
		}
		return false;
	}

}
